% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/prepareModel.R
\name{newPsydiff}
\alias{newPsydiff}
\title{newPsydiff}
\usage{
newPsydiff(
  dataset,
  latentEquations,
  manifestEquations,
  L,
  Rchol,
  A0,
  m0,
  grouping = NULL,
  parameters,
  groupingvariables = NULL,
  additional = NULL,
  srUpdate = TRUE,
  alpha = 0.2,
  beta = 2,
  kappa = 0,
  timeStep = NULL,
  integrateFunction = "default",
  breakEarly = TRUE,
  verbose = 0,
  eps = c(1e-04, 1e-05, 1e-06, 1e-07),
  direction = "right"
)
}
\arguments{
\item{dataset}{list with fields person, observations, and dt}

\item{latentEquations}{string with latent equations}

\item{manifestEquations}{string with manifest equations}

\item{L}{lower triangular Cholesky decomposition of the diffusion matrix}

\item{Rchol}{lower triangular Cholesky decomposition of the manifest variance}

\item{A0}{lower triangular Cholesky decomposition of the initial latent variance}

\item{m0}{vector of initial latent means}

\item{grouping}{string specifying the groupings}

\item{parameters}{list with named parameters}

\item{groupingvariables}{list with variables used for grouping}

\item{additional}{list for anything additional that should be passed to the latent or manifest equation}

\item{srUpdate}{boolean: Should the square root version be used for the updates?}

\item{alpha}{controls the alpha parameter of the unscented transform. Should be relatively small.}

\item{beta}{controls the beta parameter of the unscented transform. 2 should work fine for normal distributions}

\item{kappa}{controls the kappa parameter of the unscented transform. 0 should work fine for normal distributions}

\item{timeStep}{timeStep of the numerical integration. You should pass a vector as the integration might run into problems for a specific value (e.g., .01) but work fine for another (e.g., .005). The function will stop once one of the integrations resulted in no errors}

\item{integrateFunction}{which function should be used for integration? Possible are rk4, runge_kutta_dopri5, and default. default will first try rk4 and - if this fails - runge_kutta_dopri5. rk4 is often a lot slower on average but runge_kutta_dopri5 tends to get stuck from time to time.}

\item{breakEarly}{boolean: Should the integration be stopped if the prediction for at least one time point did not work? Setting to FALSE can be useful for debugging}

\item{verbose}{Values > 0 will print additional information}

\item{eps}{controls the step size in the numerical approximation of the gradients. You should pass a vector, as this will allow psydiff to try computing the gradients for an alternative step size if one of them fails}

\item{direction}{direction of the steps for gradient approximation. Possible are right, left, and central.}
}
\value{
psydiffModel that can be compiled with compileModel()
}
\description{
newPsydiff
}
\examples{
library(psydiff)
library(ctsemOMX)

## Example 3: Kalman Filter
set.seed(175446)

## define the population model:
n.subjects = 10
# set the drift matrix. Note that drift eta_1_eta2 is set to equal 0 in the population.
ct_drift <- matrix(c(-.3,.2,0,-.5), ncol = 2)

generatingModel<-ctsem::ctModel(Tpoints=5,n.latent=2,n.TDpred=0,n.TIpred=0,n.manifest=2,
                                MANIFESTVAR=diag(0.5,2),
                                LAMBDA=diag(1,2),
                                DRIFT=ct_drift,
                                DIFFUSION=matrix(c(.5,0,0,.5),2),
                                CINT=matrix(0,nrow = 2, ncol = 1),
                                T0MEANS=matrix(0,ncol=1,nrow=2),
                                T0VAR=diag(1,2), type = "omx")

# simulate a training data and testing data set
traindata <- ctsem::ctGenerate(generatingModel,n.subjects = n.subjects, wide = TRUE)
# introduce some missings:
traindata[1:4,2] <- NA
traindata[5,2:5] <- NA
traindata[6,7] <- NA
traindata[19,4] <- NA

## Build the analysis model. Note that drift eta1_eta2 is freely estimated
# although it is 0 in the population.
myModel <- ctsem::ctModel(Tpoints=5,n.latent=2,n.TDpred=0,n.TIpred=0,n.manifest=2,
                          LAMBDA=diag(1,2),
                          MANIFESTVAR=diag(.5,2), MANIFESTMEANS = "auto",
                          CINT=0,
                          DIFFUSION=matrix(c('eta1_eta1',0,0,'eta2_eta2'),2),
                          T0MEANS=matrix(c(1,2),ncol=1,nrow=2),
T0VAR="auto", type = "omx")

myModel <- ctFit(myModel, dat = traindata, objective = "Kalman", useOptimizer = T,
                 stationary = c('T0TRAITEFFECT','T0TIPREDEFFECT'))
myModel$mxobj$fitfunction$result[[1]]


## with psydiff
# prepare data
longdata <- ctWideToLong(traindata, n.manifest = 2, Tpoints =  5)
dat <- list("person" = longdata[,"id"], "observations" = longdata[,c("Y1", "Y2")], "dt" = longdata[,"dT"])

## prepare model

latentEquations <- "
dx = DRIFT*x;
"

manifestEquations <- "
y = MANIFESTMEANS + LAMBDA*x;
"

LAMBDA <- fromMxMatrix(myModel$mxobj$LAMBDA)
DRIFT <- fromMxMatrix(myModel$mxobj$DRIFT)
MANIFESTMEANS <- fromMxMatrix(myModel$mxobj$MANIFESTMEANS)

parameters <- list("LAMBDA" = LAMBDA, "DRIFT" = DRIFT,
                   "MANIFESTMEANS" = MANIFESTMEANS)

m0  <- fromMxMatrix(myModel$mxobj$T0MEANS)
A0 <- sdeModelMatrix(values = t(chol(myModel$mxobj$T0VAR$result)),
                     labels = matrix(c("T0var_eta1", "",
                                       "T0var_eta2_eta1", "T0var_eta2"),2,2,T))
Rchol = sdeModelMatrix(values = t(chol(myModel$mxobj$MANIFESTVAR$result)),
                       labels = matrix(c("", "",
                                         "", ""),2,2,T))
L = sdeModelMatrix(values = t(chol(myModel$mxobj$DIFFUSION$result)),
                   labels = matrix(c("eta1_eta1", "",
                                     "", "eta2_eta2"),2,2,T))

# set up model
model <- newPsydiff(dataset = dat, latentEquations = latentEquations,
                  manifestEquations = manifestEquations,
                  L = L, Rchol = Rchol, A0 = A0, m0 = m0,
                  parameters = parameters)

# compile model
compileModel(model)

# fit model
out <- fitModel(psydiffModel = model)
sum(out$m2LL)

# change parameter values
parval <- psydiff::getParameterValues(model)+1
psydiff::setParameterValues(parameterTable = model$pars$parameterTable,
                            parameterValues = parval, parameterLabels = names(parval))

# fit model
out <- fitModel(psydiffModel = model)
sum(out$m2LL)

## optimize model with optim
fitfun <- function(parval, model){
  psydiff::setParameterValues(parameterTable = model$pars$parameterTable,
                              parameterValues = parval, parameterLabels = names(parval))
  out <- try(fitModel(psydiffModel = model))
  if(any(class(out) == "try-error")){
    return(NA)
  }
  return(sum(out$m2LL))
}

optimized <- optim(par = parval, fn = fitfun, gr = NULL, model, method = "BFGS")
optimized$value

## additional grouping
# we will make the initial mean mm_Y1 person specific and mm_Y2 depend on a grouping parameter
grouping <- "
mm_Y1 | person;
mm_Y2 | group1;
"
groupinglist <- list("group1" = c(rep(1,5), rep(2,5)))

# set up model
model <- newPsydiff(dataset = dat, latentEquations = latentEquations,
                  manifestEquations = manifestEquations, grouping = grouping,
                  L = L, Rchol = Rchol, A0 = A0, m0 = m0,
                  parameters = parameters, groupingvariables = groupinglist, compile = TRUE)
parval <- psydiff::getParameterValues(model)

optimized <- optim(par = parval, fn = fitfun, gr = NULL, model, method = "BFGS")
optimized$par
optimized$value

## The following example is taken from ctsem and also demonstrates the use of the GIST optimizer
library(ctsemOMX)
data('ctExample3')
model <- ctModel(n.latent = 1, n.manifest = 3, Tpoints = 100,
                 LAMBDA = matrix(c(1, 'lambda2', 'lambda3'), nrow = 3, ncol = 1),
                 CINT= matrix('cint'), T0VAR = diag(1),
                 MANIFESTMEANS = matrix(c(0, 'manifestmean2', 'manifestmean3'), nrow = 3,
                                        ncol = 1))
fit <- ctFit(dat = ctExample3, ctmodelobj = model, objective = 'Kalman',
             stationary = c("T0TRAITEFFECT", "T0TIPREDEFFECT"), useOptimizer = F)
omxGetParameters(fit$mxobj)
fit$mxobj$fitfunction$result[[1]]

latentEquations <- "
dx(0) = cint + driftEta1*x(0);
"
manifestEquations <- "
y(0) = x(0);
y(1) = manifestmean2 + lambda2*x(0);
y(2) = manifestmean3 + lambda3*x(0);
"

parameters <- list("driftEta1" = -.1,
                   "cint" = 2,
                   "lambda2" = 3,
                   "lambda3" = 2,
                   "manifestmean2" = 1,
                   "manifestmean3" = 3)

m0  <- fromMxMatrix(fit$mxobj$T0MEANS)
A0 <- sdeModelMatrix(values = fit$mxobj$T0VARchol$result,
                     labels = matrix("",1,1))
Rchol = sdeModelMatrix(values = fit$mxobj$MANIFESTVARchol$result,
                       labels = matrix(c("mvar1", "", "",
                                         "", "mvar2", "",
                                         "", "", "mvar3"),3,3,T))
L = sdeModelMatrix(values = fit$mxobj$DIFFUSIONchol$result,
                   labels = matrix(c("lvar"),1,1,T))

longdata <- ctWideToLong(ctExample3, n.manifest = 3, Tpoints =  100)
dat <- list("person" = longdata[,"id"], "observations" = longdata[,c("Y1", "Y2", "Y3")], "dt" = longdata[,"dT"])

# set up model
model <- newPsydiff(dataset = dat, latentEquations = latentEquations,
                    manifestEquations = manifestEquations,
                    L = L, Rchol = Rchol, A0 = A0, m0 = m0,
                    parameters = parameters, verbose = 0, kappa = 0, alpha = .81, beta = 2)

compileModel(model)
out <- fitModel(model)
out$m2LL
getParameterValues(model)

startingValues <- psydiff::getParameterValues(model)
adaptiveLassoWeights <- rep(1, length(startingValues))
names(adaptiveLassoWeights) <- names(startingValues)
regularizedParameters <- "lvar"
lambda <- 0

opt <- GIST(model = model, startingValues = startingValues, lambda = lambda,
            adaptiveLassoWeights = adaptiveLassoWeights,
            regularizedParameters = regularizedParameters,
            verbose = 1, maxIter_out = 200, sig = .4, break_outer = 10e-20)

getParameterValues(opt$model)
out <- fitModel(opt$model)
matplot(out$predictedManifest, type = "l")
points(dat$observations[,1])
points(dat$observations[,2])
points(dat$observations[,3])
}
